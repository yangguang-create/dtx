# TCC方案

```txt
TCC要求每个分支事务都完成三个操作：
预处理Try:
	业务检查，比如A转账给B，首先检查余额是否足够
    资源预留，方便后续阶段操作。
    此阶段仅是一个初步操作，它和后续的Confirm 一起才能 真正构成一个完整的业务逻辑。
确认Confirm
	确认提交。try成功，一般confirm也成功。
	Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则 认为 Confirm阶段是不会出错	   的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引 入重试机制或人工处理。
撤销Cancle
	与try阶段相反的操作。
	此阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采 用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。
	
confirm和cancle这两个阶段执行失败时需要进行重试。但是在重试的时候，一段代码重复执行的时候必须保证幂等性。

try成功-->confirm必须成功
try失败-->cancle也必须要回滚成功
```

## tcc解决方案-Hmily

```json
hmily是利用AOP对参与分布式事物的本地方法与远程方法进行拦截。（拦截之后，就可以知道每个分布式事务的执行情况，通过拦截的方式，可以渗透到本地方法中。）然后决定调用另一方的try还是confirm还是cancle。

hmily不需要事务的协调器，但是需要提供一个数据库。来记录事务控制过程中的记录。（例如，分支事务表）

hmily实现tcc服务和普通的服务是一样的。只需要暴露一个接口，也就是他的try方法。confirm和cancle的业务逻辑只是因为全局事务提交/回滚的需要才提供的。

confirm和cancle业务只需要被hmily TCC事务框架发现即可。不需要被调用它的其他业务服务感知。
```



## TCC需要注意三种异常处理分别是空回滚、幂等、悬挂

```json
//空回滚
	针对cancle来说的，在执行cancle的时候，需要判断try有没有执行。如果try没有执行。就不要执行cancle
此时cancle方法需要识别出这是一个空回滚，然后直接返回成功。
	出现空回滚的原因是：当一个分之事务所在的服务器宕机或者网络延迟。导致分支事务失败的时候。这时候其实是没有执行try阶段的。但是当故障恢复后，分布式事务进行回滚，会调用二阶段的cancle，从而形成空回滚。
	解决的思路是要识别这次cancle方法执行的是一个空回滚。
	也就是说需要明确知道一阶段的try方法是不是执行了。如果执行了，那就正常回滚。如果没有执行，就空回滚。因为TM发起全局事务的时候，会生成全局事务记录。全局事务id会贯穿整个分布式事务调用链。
	这时，只需要额外增加一张分支事务表，其中有全局事务ID和分支事务ID。在第一阶段try方法里面会往这个表中插入一条记录，表示一阶段执行完成。
	只需要在cancle接口里面读取该记录，如果记录存在，说明一阶段try执行了，确实把记录插到全局事务表里面了。这是就可以正常回滚。如果记录不存在，说明第一阶段没有执行。那么这次cancle操作就是空回滚。

//幂等
	为了保证TCC第二阶段提交重试机制不会引发数据不一致，那么要求TCC二阶段try\confirm\cancle接口保证幂等。这样就不会重复使用或者释放资源。上述三个阶段都是由单独的线程调用，可能会出现重复调用。所以上面的是三个方法都要实现幂等。
	如果幂等没有控制好，会导致数据不一致的情况。
	要实现幂等的操作，可以在cancle执行完成后往数据库对应的表cancel_log中插入一条日志。
	下一次执行的时候，先判断cancel_log日志中有没有信息。如果有，就不能再去执行来了。以此实现幂等的控制。

//悬挂
	针对try来说的，在try阶段，判断cancle和confirm有没有执行。如果后面的两个阶段已经执行了。那么try就不要执行了。
	出现的原因是：在rpc调用分之事务try时，需要先注册分支事务，然后在进行rpc调用。
	如果rpc调用的时候网络发生拥堵，或者超时，TM就会通知RM回滚该分布式事务，但是有可能在执行回滚之后，rpc远程调用才真正到达，才开始真正执行。
	而一个try方法预留的业务资源。只有该分布式事务才可以用。但是由于在try执行前已经执行了cancle回滚操作。那么该分之事务预留的这些资源就不能处理了。这种情况就是悬挂，也就是由于try的执行导致预留资源后面没法处理。因为前面由于超时原因已经把事务回滚了。
	解决思路就是，如果第二阶段已经执行完成，那么第一阶段就不要执行了。所以再执行一阶段事务try方法时要判断分支事务记录表中是否已经有二阶段的事务记录。如果有，说明已经有悬挂，那么try就不要执行了。
```

## 数据库组成

```sql
bank1和bank2数据库中，有三个表
	local_cancle_log:
	local_confirm_log:
	local_try_log:
这三个表用于记录对应阶段的执行情况。可以实现幂等的控制。

CREATE TABLE `local_try_log` ( 
    `tx_no` varchar(64) NOT NULL COMMENT '事务id', 
    `create_time` datetime DEFAULT NULL, 
     PRIMARY KEY (`tx_no`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 
CREATE TABLE `local_confirm_log` ( 
    `tx_no` varchar(64) NOT NULL COMMENT '事务id', 
    `create_time` datetime DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 
CREATE TABLE `local_cancel_log` ( 
    `tx_no` varchar(64) NOT NULL COMMENT '事务id', 
    `create_time` datetime DEFAULT NULL, 
     PRIMARY KEY (`tx_no`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8

hmily数据库:
	这个数据库是空的。
	hmily事务在执行的过程中，会自动的往该数据库中添加表，全局事务记录表，记录的是全局事务id和分支事务id。用来记录全局事务的运行状态。


```

## tcc总结

```json
和2pc相比较。2pc的操作都是跨库的层面。tcc则是在应用层处理。需要通过业务逻辑来实现。
这种分布式事务实现的方式在于可以让应用自己定义数据的操作粒度。避免锁冲突、提高吞吐量。

而tcc的不足之处在于对于应用程序的侵入性非常高。业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，实现难度比较大。需要按照网络状态，系统故障等不同的失败原因实现不同的回滚策略。
```



# 可靠消息最终一致性方案

```json
可靠消息最终一致性指的是当事务发起方(消息的生产者)执行完成本地事务后，发出一条消息
事务的参与方(消息的消费者)一定能够接收消息并处理事务成功。
此方案强调的是只要消息发给事务参与方，最终事务要达到一致。

可靠指的是：消息 一定能发送给事务接受者
最终一致性指的是，消息接受者最终一定能保证数据一致。

此方案是利用消息中间件来完成。
事务发起方(消息生产者)和消息中间件之间  、  事务接受者(消息消费者)和消息中间件之间
都是通过网络进行通信，由于网络的不确定性可能导致分布式事务问题。
因此：可靠消息最终一致性方案要解决以下问题：
#本地事务与消息发送的原子性问题
事务发起方在本地事务执行成功后消息 必须发送出去。否则就丢弃消息。也就是要实现本地事务和消息发送的原子性。要么都成功，要么都失败。
这个事务是实现可靠消息最终一致性方案的关键问题。

#事务参与方(消息的消费者)接收消息的可靠性
指的是事务参与方一定要接收到消息。加上前面的事务发起方发送消息到消息队列。两个过程都要可靠。
如果消息接受者接收不到。那么就需要重发机制。

#消息重复消费的问题
由于消费者和消息中间件通过网络连接。若某一个消费者超时但是消费消息成功。
此时消息中间件会重复投递此消息，就导致消息的重复消费。
要解决消息的重复消费，就需要把事务参与方的方法实现为幂等。

```

## 解决方案

### 本地消息表方案

```json
以注册用户送积分的问题来说
#本地消息表方案
通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送到消息中间件，等到确认将消息发送给消费方后再将消息删除。
1：用户注册。
用户在本地事务中新增用户和增加积分消息日志。这样用户表 和消息表通过本地事务保持了一致。本地数据库操作与记录消息日志操作具备原子性。

2：定时扫描日志
如何保证消息发送给消息队列呢？
经过第一步消息已经写到了本地的消息日志中，但这时只是在本地。可以启动独立的线程，定时对消息日志表中的消息进行扫描并发送到消息中间件。在消息中间件反馈发送成功后，可以删除该消息日志。否则等待定时任务的下一周期重试。

3：消息消费
如何保证消费者一定能消费消息呢？
消费者监听消息队列。
这里可以使用MQ的ACK(即消息确认)机制。消费者监听MQ，如果消费者收到消息并且任务处理完成后向MQ发送ack(消息确认)，此时说明消费者正常消费消息。MQ不在向消费者推送消息，否则MQ会不断的重试向消费者发送消息。
正是由于中间件会重复向消费者发送消息，所以消费消息的服务的响应功能需要实现幂等。

```

### RocketMQ事务消息方案

```json
appache rocketMQ4.3之后的版本正式支持事务消息，为分布式事务实现提供了便利性支持。
RocketMQ事务消息设计主要解决了Producer端的消息发送和本地事务执行的原子性问题。RocketMQ的设计中broker和producer端的双向通信能力，可以让broker天生作为一个事务协调者存在。而rocketMQ本身提供的存储机制为事务消息提供了持久化能力。RocketMQ的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。

RocketMQ4.3之后，实现了完整的事务消息，实际上其实是对本地消息表的一个封装。将本地消息表移到了MQ内部，解决了Producer端的消息发送和本地事务执行的原子性问题。 
```

### 小结

```json
可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性.
1、本地事务与消息发送的原子性问题
2、事务参与方接收消息的可靠性。
可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。
引入消息机制后，同步的事务操作变为基于消 息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，
并实现了两个服务的解耦。
```



# 最大努力通知方案

```json
#最大努力通知也是一种结局分布式事务的方案。
以充值为例：
1：账户 系统调用充值系统接口
2：充值系统完成支付结果处理向账户系统发起充值结果通知.
	如果通知失败，则充值系统按策略进行重试。
3：账户系统接收到充值结果通知后修改充值状态。
4：账户系统未收到通知会主动调用充值系统的接口查询充值结果。

所以：最大努力同志方案的目标是：
目标：发起通知发通过一定的机制尽最大努力将业务结果通知到接收方。也就是重点是充值结果需要通知给账户系统。

#具体包括：
1:有一定的消息重复通知机制。
因为接收方可能没有接收到通知，此时要有一定的机制对消息重复通知。
2:消息校对机制。
如果尽最大努力也没有通知到接收方，或者接收方消费消息后再次通知，此时可由接收方主动向通知方查询消息信息来满足需求。

#最大努力通知和可靠消息一致性有什么不同？
1：解决方案思想不同
可靠消息一致性，发起通知放需要保证将消息发送出去，并且把消息发送到接收方，消息的可靠性有发起通知方来保证。
最大努力通知，发起通知方尽最大努力将业务处理结果通知到接收方，但是消息可能接收不到，此时需要接收方主动调用通知方的接口来查询业务处理结果，通知到可靠性由接收方保证。

2：两者的业务场景不同
可靠消息一致性关注的是交易过程的事务一致，是通过异步的方式完成交易。
最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知到接收方。

3：技术解决方向不同
可靠消息一致性要解决的是消息从发出到接收到的一致性。即消息发出并被成功接收。
最大努力通知无法保证消息从发出到接收的一致性，只提供接收消息的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息(也就是业务的处理结果)。
```

## 解决方案

### 方案1

```json
通过对最大努力通知的理解，采用MQ的ack机制就可以实现最大努力通知。
本方案是利用MQ的ack机制由MQ向接收通知方发送通知，流程如下：
1、发起通知方将通知发给MQ。（这里的消息就是普通消息）
使用普通消息机制将通知发给MQ。
注意：如果消息没有发出去可由接收通知方主动请求发起通知方查询业务执行结果。
2、接收通知方监听 MQ。
3、接收通知方接收消息，业务处理完成回应ack。
4、接收通知方若没有回应ack则MQ会重复通知。
	MQ会按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 （如果MQ采用 		rocketMq，在broker中可进行配置），直到达到通知要求的时间窗口上限。
5、接收通知方可通过消息校对接口来校对消息的一致性。
```

### 方案2

```json
本方案也是利用MQ的ack机制，与方案1不同的是应用程序向接收通知方发送通知
1、发起通知方将通知发给MQ。
	使用可靠消息一致方案中的事务消息保证本地事务与消息的原子性，最终将通知先发给MQ。
2、通知程序监听 MQ，接收MQ的消息。
	方案1中接收通知方直接监听MQ，方案2中由通知程序监听MQ。
	通知程序若没有回应ack则MQ会重复通知。
3、通知程序通过互联网接口协议（如http、webservice）调用接收通知方案接口，完成通知。
	通知程序调用接收通知方案接口成功就表示通知成功，即消费MQ消息成功，MQ将不再向通知程序投递通知消 		息。
4、接收通知方可通过消息校对接口来校对消息的一致性。
```

### 方案1和方案2的不同点： 

```json
1、方案1中接收通知方与MQ接口，即接收通知方案监听 MQ，此方案主要应用与内部应用之间的通知。
2、方案2中由通知程序与MQ接口，通知程序监听MQ，收到MQ的消息后由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。

```

### 小结

```json
最大努力通知方案是分布式事务中对一致性要求最低的一种,适用于一些最终一致性时间敏感度低的业务；
最大努力通知方案需要实现如下功能：
1、消息重复通知机制。
2、消息校对机制。
```

# 分布式事务综合案例分析

```json
前边我们已经学习了四种分布式事务解决方案，
2PC、TCC、可靠消息最终一致性、最大努力通知，每种解决方案 我们通过案例开发进行学习，

本章节我们结合互联网金融项目中的业务场景，来进行分布式事务解决方案可行性分析。
花联网金融项目中的很多业务场景都需要使用分布式事务来解决。
```

## 系统介绍

```json
```

